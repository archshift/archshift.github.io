<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width" />
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/prism.css">
    <script src="/prism.js"></script> 
    <title>The Most Dangerous Memory</title>
    
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-31609280-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-31609280-3');
</script>

</head>
<body>
    <div id="title">
        <h1>a blog</h1>
        <p>by <a href="/">
            Gui Andrade
        </a></p>
    </div>

    <div id="post">
        <h1>The Most Dangerous Memory</h1>
<p>Recently I embarked on a fun little debugging journey.</p>
<p>Embedded work, of course. A working debugger? Never heard of one (I could ostensibly use the GDB stub, but setting a breakpoint was liable to crash the whole system about 75% of the time, and otherwise stepping a line took upwards of 30 seconds).</p>
<p>~</p>
<p>My story begins with a change to the build environment. Goodbye <code>-O2</code>; hello <code>-O0 -g</code>! The goal’s to use what little remote debugging I have to fix a silly ol’ bug. Easy fix. But now there’s this weird hang just before my program’s supposed to quit.</p>
<p>Weird. The code sends a message and waits for a reply, which never comes. I look at the thread on the other side. It’s waiting to receive the message. So… the message passing code is broken now? But I haven’t touched it, and it’s been working for just about ever. </p>
<p>I look a little closer. One thing I can actually reliably do with my debugger is pause, and read out some structures wherever the roulette wheel lands (useful when things hang). Turns out my <code>channel_id</code> is now <code>0</code>. What? When I started executing, it was a nice, friendly <code>149</code>. But something’s reverted it to zero. Is deinitialization happening too early? Nope. Maybe memory corruption?</p>
<p>And so, like a <em>seasoned engineer</em> I sprinkle <code>assert(foo-&gt;channel_id)</code> about the codebase. All in all a beautifully round 100 asserts did the trick. They spanned about 7 or 8 abstraction layers, with the deepest assert pair telling me that <code>channel_id</code> becomes zero somewhere in the middle of a some peripheral driver code. The culprit function was a long, long sequence of updates to memory-mapped I/O registers. Initialization code, I suppose (this was way underneath any abstraction I’d yet dealt with). All in all, that autogenerated peripheral-init function was probably about 5000 lines long, with exactly one local variable. Pretty cute code.</p>
<p>So somewhere in the middle of this function, which has absolutely nothing to do with my clobbered <code>channel_id</code> variable on the heap, there must a sketchy memory write or two. I put my thinking cap on.</p>
<p>Of course. It’s got to be a timing bug related to some interrupt, right? But after running my code some 10 times over, the exact same memory was being clobbered somewhere in a very precise region of assertions. No timing bug I’ve ever seen has been so consistent. So maybe it wasn’t timing after all.</p>
<p>Aha! One of the register writes must set up a faulty DMA write to my memory. So I pull out the massive spec sheet, flip through to the relevant component. Hmmmm. No DMA writes. No DMA reads. Nothing about this peripheral touches memory.</p>
<p>Foiled again, I can’t think of anything to do but pull up the assembly output for that function. Again, since it’s 5000 lines of register writes I doubt I’ll be able to glean anything very interesting from the assembly output. But I look.</p>
<p>Wait. What?</p>
<p>You’re telling me this function which uses exactly one (1) local variable, a <code>uintptr_t</code> to be exact, reserves 10kiB (!!!!!) of stack space? A spark of an idea in my head, I go back and print out the exact addresses for my clobbered data (in the heap) and my stack pointer in the reg-write function.</p>
<p>Isn’t that something. The stack is overflowing into the heap, isn’t it?</p>
<h2>Come on, <code>clang</code>!</h2>
<p>I was very surprised to learn that a sequence of function calls, even without any local variables around, might just occupy stack space linear to the number of calls. This is in <code>clang</code> on ARM, with no optimizations. <a href="https://godbolt.org/z/mQ7p_2">You can also see this behavior on <code>clang</code> in x86_64</a>. GCC doesn’t have this problem, probably because of some GPL fairy dust or something.</p>
<p>Instead I expected that the arguments of each function (there were only two args) would be computed in reused registers. After all, ARM has no shortage of general purpose registers, and the ABI specifies that the first 4 arguments of a function are passed on callee-saved registers.</p>
<p>I also expected that if any stack space was used to call a function, <code>clang</code> would reuse the same words in the stack such that the reserved stack space wouldn’t grow with the number of function calls.</p>
<h2>Moral of the story?</h2>
<p>The edge of the stack is a spooky place to be. This time it was C code, but of course in C you generally take your life into your own hands. But this could have as easily happened in a language like Rust, which doesn’t do anything fancy to prevent excess stack usage and in fact heavily encourages you to rely on the stack as your primary store of data. So:</p>
<p>Audit your autogenerated code, and better yet audit your stack usage with compiler flags like <code>-fstack-usage</code>. But again, that's a GCC option, not something that you can easily use with Clang. And even when you can use GCC, such tools can't help you with dynamically determined stack usage, like when you use recursion or variable-length arrays. But if you're using these features without reliable stack protection (<a href="https://blogs.gnome.org/markmc/2005/05/11/stack-guard-page/">guard pages</a>, etc.), you pretty much assume responsibility for your program to explode in unexpected ways.</p>
<p>I suppose if there's any single takeaway from my sad story, it would be a three-word mantra:</p>
<p><strong><em>Stack considered harmful!</em></strong></p>
<p>So just use Java, where everything's on the heap? D:</p>
    </div>
</body>
</html>
