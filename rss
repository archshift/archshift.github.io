<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>A Blog (by Gui Andrade)</title><link>https://guiand.xyz/rss</link><description>A blog about random programming topics, usually related to optimization or compilers.</description><language>en-US</language><lastBuildDate>Sat, 20 Apr 2024 14:35:10 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>Getting my CPF remotely from the US</title><link>https://guiand.xyz/blog-posts/getting-my-cpf.html</link><description>I never figured out my Brazilian documentation until adulthood. Here's how I finally registered for my CPF.</description><author>Gui Andrade</author><pubDate>Sat, 20 Apr 2024 00:00:00 GMT</pubDate></item><item><title>Bootstrapping Debian onto the PolarFire SoC board</title><link>https://guiand.xyz/blog-posts/bootstrapping-debian-polarfire-soc.html</link><description>The PolarFire SoC is an affordable, useful, and widely available Linux-capable RISC-V board. Here's how you can run Debian on it.</description><author>Gui Andrade</author><pubDate>Tue, 16 Mar 2021 00:00:00 GMT</pubDate></item><item><title>Tamper-protecting huge amounts of data, just in time</title><link>https://guiand.xyz/blog-posts/tamper-protecting-just-in-time.html</link><description>How do you ensure the integrity of vast amounts of data all at once? How can you tell if your evil maid has corrupted your data? Merkle trees hold the answer.</description><author>Gui Andrade</author><pubDate>Mon, 11 May 2020 00:00:00 GMT</pubDate></item><item><title>The Most Dangerous Memory</title><link>https://guiand.xyz/blog-posts/most-dangerous-memory.html</link><description>Clang in -O0 can do some dangerous things. It might just overflow your stack!</description><author>Gui Andrade</author><pubDate>Tue, 05 Nov 2019 00:00:00 GMT</pubDate></item><item><title>Compile-time coprocessor codegen, with Rust macros</title><link>https://guiand.xyz/blog-posts/macro-assembly-codegen.html</link><description>Rust macros are flexible enough to implement a sort of DSL for assembly. This is useful for building up Direct Memory Access sequences.</description><author>Gui Andrade</author><pubDate>Fri, 03 May 2019 00:00:00 GMT</pubDate></item><item><title>Implementing specialization in Rust by matching marker types</title><link>https://guiand.xyz/blog-posts/compile-time-unions.html</link><description>Traits are a good way to select code at the type system level. But with some hackeryyou could instead specialize based on a sort of higher-order 'type map'.</description><author>Gui Andrade</author><pubDate>Sat, 19 Jan 2019 00:00:00 GMT</pubDate></item><item><title>Storing unboxed trait objects in Rust</title><link>https://guiand.xyz/blog-posts/unboxed-trait-objects.html</link><description>Trait objects generally need to be stored on the heap. But normal heap datastructures like Vec need an additional layer of Box to store trait objects. We can eliminate that.</description><author>Gui Andrade</author><pubDate>Sat, 10 Nov 2018 00:00:00 GMT</pubDate></item><item><title>Hacking around the Rust type-system to provide ergonomic bitfields</title><link>https://guiand.xyz/blog-posts/bitfields.html</link><description>Stable Rust with classical macros generally isn't friendly to implementing bitfield structures. But there's a way.</description><author>Gui Andrade</author><pubDate>Mon, 03 Sep 2018 00:00:00 GMT</pubDate></item></channel></rss>